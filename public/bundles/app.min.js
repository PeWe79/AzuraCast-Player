/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 168:
/***/ (() => {

/**
 * Vue component used to toggle channel favorite
 */
Vue.component('fav-btn', {
  props: {
    id: {
      type: String,
      "default": '',
      required: true
    },
    text: {
      type: String,
      "default": '',
      required: false
    },
    active: {
      type: Boolean,
      "default": false
    }
  },
  template: "\n    <button class=\"hover-text focus-text\" @click.stop=\"$emit('change', id, !active)\" title=\"Toggle save favorite station\">\n      <span>\n        <i v-if=\"active\" class=\"ico ico-favs-check text-primary fx fx-drop-in\" key=\"on\"></i>\n        <i v-else class=\"ico ico-favs-add fx fx-drop-in\" key=\"off\"></i>\n      </span>\n      <span v-if=\"text\">&nbsp; {{ text }}</span>\n    </button>"
});

/***/ }),

/***/ 998:
/***/ (() => {

/**
 * Vue custom filters
 */

// comma separate long numerical values
Vue.filter('toCommas', function (num, decimals) {
  var o = {
    style: 'decimal',
    minimumFractionDigits: decimals,
    maximumFractionDigits: decimals
  };
  return new Intl.NumberFormat('en-US', o).format(num);
});

// sanitize text data by only allowing alnums and some symbols
Vue.filter('toText', function (str, def) {
  str = String(str || '').replace(/[^\w\`\'\-\,\.\!\?]+/g, ' ').replace(/\s\s+/g, ' ').trim();
  return str || String(def || '');
});

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";

// EXTERNAL MODULE: ./src/js/filters.js
var filters = __webpack_require__(998);
// EXTERNAL MODULE: ./src/js/favorite.js
var favorite = __webpack_require__(168);
;// CONCATENATED MODULE: ./src/js/config.js
/* harmony default export */ const config = ({
  api_url: 'https://stream.cloudmu.id'
});
;// CONCATENATED MODULE: ./src/js/api.js
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
/**
 * AzuraCast API handler
 */


/* harmony default export */ const api = ({
  // get station data from api
  getChannels: function getChannels(callback) {
    var _this = this;
    var apiurl = config.api_url + '/api/stations';
    var error = 'There was a problem fetching the latest list of music channels from AzuraCast.';
    axios.get(apiurl).then(function (res) {
      var list = _this._parseChannels(res.data);
      if (!list.length) return callback(error, []);
      return callback(null, list);
    })["catch"](function (e) {
      return callback(error + String(e.message || ''), []);
    });
  },
  // fetch songs for a channel
  getSongs: function getSongs(channel, callback) {
    var apiurl = channel.songsurl || '';
    var title = channel.name || '...';
    var error = 'There was a problem loading the list of songs for channel ' + title + ' from AzuraCast.';
    axios.get(apiurl).then(function (res) {
      if (!res.data) return callback(error, []);
      return callback(null, res.data);
    })["catch"](function (e) {
      return callback(error + String(e.message || ''), []);
    });
  },
  // parse station list from api response
  _parseChannels: function _parseChannels(station) {
    var output = [];
    if (Array.isArray(station)) {
      var _iterator = _createForOfIteratorHelper(station),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var c = _step.value;
          c.plsfile = c.playlist_pls_url;
          c.mp3file = c.listen_url;
          c.songsurl = config.api_url + '/api/nowplaying/' + c.id;
          c.image = '/public/img/' + c.shortcode + '.png';
          c.infourl = c.url;
          c.twitter = c.twitter ? 'https://twitter.com/@' + c.twitter : '';
          c.route = '/station/' + c.shortcode;
          c.listeners = c.mounts[0].listeners.current | 0;
          c.updated = c.updated | 0;
          c.favorite = false;
          c.active = false;
          output.push(c);
          // console.log("DATA => "+c.image);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    return output;
  }
});
;// CONCATENATED MODULE: ./src/js/audio.js
/**
 * Audio handler object
 */
/* harmony default export */ const audio = ({
  _context: null,
  _audio: null,
  _source: null,
  _gain: null,
  _analyser: null,
  _freq: new Uint8Array(32),
  _hasfreq: false,
  _counter: 0,
  _events: {},
  // setup audio routing, called after user interaction, setup once
  setupAudio: function setupAudio() {
    var _this = this;
    if (this._audio && this._context) return;
    this._audio = new Audio();
    this._context = new (window.AudioContext || window.webkitAudioContext)();
    this._source = this._context.createMediaElementSource(this._audio);
    this._analyser = this._context.createAnalyser();
    this._gain = this._context.createGain();
    this._analyser.fftSize = 32;
    this._source.connect(this._analyser);
    this._source.connect(this._gain);
    this._gain.connect(this._context.destination);
    this._audio.addEventListener('canplay', function () {
      _this._freq = new Uint8Array(_this._analyser.frequencyBinCount);
      _this._audio.play();
    });
    ['waiting', 'playing', 'ended', 'stalled', 'error'].forEach(function (event) {
      _this._audio.addEventListener(event, function (e) {
        return _this.emit(event, e);
      });
    });
  },
  // add event listeners to the audio api
  on: function on(event, callback) {
    if (event && typeof callback === 'function') {
      this._events[event] = callback;
    }
  },
  // emit saved audio event
  emit: function emit(event, data) {
    if (event && this._events.hasOwnProperty(event)) {
      this._events[event](data);
    }
  },
  // update and return analyser frequency value (0-1) to control animations
  getFreqData: function getFreqData(playing) {
    if (!this._analyser) return 0;

    // this is not working on some devices running safari
    this._analyser.getByteFrequencyData(this._freq);
    var _freq = Math.floor(this._freq[4] | 0) / 255;

    // indicate that a freq value can be read
    if (!this._hasfreq && _freq) {
      this._hasfreq = true;
    }

    // frequency data available
    if (this._hasfreq) return _freq;

    // return fake counter if no freq data available (safari workaround)
    if (playing) {
      this._counter = this._counter < .6 ? this._counter + .01 : this._counter;
    } else {
      this._counter = this._counter > 0 ? this._counter - .01 : this._counter;
    }
    return this._counter;
  },
  // set audio volume
  setVolume: function setVolume(volume) {
    if (!this._gain) return;
    volume = parseFloat(volume) || 0;
    volume = volume > 1 ? volume / 100 : volume;
    volume = volume > 1 ? 1 : volume;
    volume = volume < 0 ? 0 : volume;
    this._audio.muted = volume <= 0 ? true : false;
    this._gain.gain.value = volume;
  },
  // stop playing audio
  stopAudio: function stopAudio() {
    if (!this._audio) return;
    try {
      this._audio.pause();
    } catch (e) {}
    try {
      this._audio.stop();
    } catch (e) {}
    try {
      this._audio.close();
    } catch (e) {}
  },
  // play audio source url
  playSource: function playSource(source) {
    this.setupAudio();
    this.stopAudio();
    if (this._context.state === 'suspended') {
      this._context.resume().then(function () {
        console.log('Audio context has been resumed.');
      });
    }
    this._audio.src = String(source || '') + '?x=' + Date.now();
    this._audio.preload = 'metadata';
    this._audio.crossOrigin = 'anonymous';
    this._audio.autoplay = false;
    this._audio.load();
  }
});
;// CONCATENATED MODULE: ./src/js/sphere.js
/**
 * ThreeJS scene sphere object
 */
/* harmony default export */ const sphere = ({
  group: null,
  shapes: [],
  move: new THREE.Vector3(0, 0, 0),
  touch: false,
  ease: 8,
  // create and add sphere to scene
  create: function create(box, scene) {
    this.group = new THREE.Object3D();
    var shape1 = new THREE.CircleGeometry(1, 10);
    var shape2 = new THREE.CircleGeometry(2, 20);
    var points = new THREE.SphereGeometry(100, 30, 14).vertices;
    var material = new THREE.MeshNormalMaterial({
      transparent: true,
      opacity: 0,
      side: THREE.DoubleSide
    });
    var center = new THREE.Vector3(0, 0, 0);
    var radius = 12;
    for (var i = 0; i < points.length; i++) {
      var _points$i = points[i],
        x = _points$i.x,
        y = _points$i.y,
        z = _points$i.z;
      var home = {
        x: x,
        y: y,
        z: z
      };
      var cycle = THREE.Math.randInt(0, 100);
      var pace = THREE.Math.randInt(10, 30);
      var shape = new THREE.Mesh(i % 2 ? shape1 : shape2, material);
      shape.position.set(x, y, z);
      shape.lookAt(center);
      shape.userData = {
        radius: radius,
        cycle: cycle,
        pace: pace,
        home: home
      };
      this.group.add(shape);
    }
    this.touch = 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
    this.group.position.set(40, 5, 0);
    this.group.rotation.x = Math.PI / 2 + .6;
    scene.add(this.group);
  },
  // animate sphere on frame loop
  update: function update(box, mouse, freq) {
    var xoff = box.width < 800 ? 0 : 40;
    var zoff = box.width < 800 ? -60 : 20;
    var zmod = .5 + .5 * freq;

    // prevent sphere from moving left/right on touch devices
    if (this.touch) {
      this.group.position.x = xoff;
    } else {
      this.move.x = xoff + -(mouse.x * 0.012);
      this.group.position.x += (this.move.x - this.group.position.x) / this.ease;
      this.group.position.y += (this.move.y - this.group.position.y) / this.ease;
    }
    // move on z-axis with music data and rotate
    this.group.position.z = zoff + 80 * freq;
    this.group.rotation.y -= 0.003;

    // adjust individual sphere points
    for (var i = 0; i < this.group.children.length; i++) {
      var shape = this.group.children[i];
      var _shape$userData = shape.userData,
        radius = _shape$userData.radius,
        cycle = _shape$userData.cycle,
        pace = _shape$userData.pace,
        home = _shape$userData.home;
      shape.material.opacity = .2 + .8 * freq;
      shape.position.set(home.x, home.y, home.z);
      shape.translateZ(zmod * Math.sin(cycle / pace) * radius);
      shape.userData.cycle++;
    }
  }
});
;// CONCATENATED MODULE: ./src/js/scene.js
function scene_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = scene_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function scene_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return scene_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return scene_arrayLikeToArray(o, minLen); }
function scene_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
/**
 * ThreeJS scene handler
 */

/* harmony default export */ const scene = ({
  _wrap: null,
  _canvas: null,
  _renderer: null,
  _scene: null,
  _camera: null,
  _box: null,
  _mouse: {
    x: 0,
    y: 0
  },
  _objects: [],
  // setup animation canvas
  setupCanvas: function setupCanvas() {
    this._wrap = document.querySelector('#player-wrap');
    this._canvas = document.querySelector('#player-canvas');
    this._box = this._wrap.getBoundingClientRect();

    // setup scene and renderer
    this._scene = new THREE.Scene();
    this._renderer = new THREE.WebGLRenderer({
      canvas: this._canvas,
      alpha: true,
      antialias: true,
      precision: 'lowp'
    });
    this._renderer.setClearColor(0x000000, 0);
    this._renderer.setPixelRatio(window.devicePixelRatio);

    // setup camera
    this._camera = new THREE.PerspectiveCamera(60, this._box.width / this._box.height, 0.1, 20000);
    this._camera.lookAt(this._scene.position);
    this._camera.position.set(0, 0, 300);
    this._camera.rotation.set(0, 0, 0);

    // add and create objects
    this._objects.push(sphere);
    var _iterator = scene_createForOfIteratorHelper(this._objects),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var o = _step.value;
        o.create(this._box, this._scene);
      }
      // setup events
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    window.addEventListener('mousemove', this.updateMouse.bind(this));
    window.addEventListener('resize', this.updateSize.bind(this));
    this.updateMouse();
    this.updateSize();
  },
  // update custom objects in 3d scene
  updateObjects: function updateObjects(freq) {
    var _iterator2 = scene_createForOfIteratorHelper(this._objects),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var o = _step2.value;
        o.update(this._box, this._mouse, freq);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    this._renderer.render(this._scene, this._camera);
  },
  // update canvas size
  updateSize: function updateSize() {
    if (!this._wrap || !this._canvas) return;
    this._box = this._wrap.getBoundingClientRect();
    this._canvas.width = this._box.width;
    this._canvas.height = this._box.height;
    this._camera.aspect = this._box.width / this._box.height;
    this._camera.updateProjectionMatrix();
    this._renderer.setSize(this._box.width, this._box.height);
  },
  // update mouse position from center of canvas
  updateMouse: function updateMouse(e) {
    if (!this._box) return;
    var centerX = this._box.left + this._box.width / 2;
    var centerY = this._box.top + this._box.height / 2;
    if (e) {
      this._mouse.x = Math.max(0, e.pageX || e.clientX || 0) - centerX;
      this._mouse.y = Math.max(0, e.pageY || e.clientY || 0) - centerY;
    } else {
      this._mouse.x = centerX;
      this._mouse.y = centerY;
    }
  }
});
;// CONCATENATED MODULE: ./src/js/utils.js
/**
 * Common utils
 */
/* harmony default export */ const utils = ({
  // get search results off a list for an obj key
  search: function search(list, key, _search) {
    var regxp = new RegExp('^(' + _search + ')', 'i');
    return list.filter(function (item) {
      return regxp.test(item[key]);
    });
  },
  // sort objects in an array by a key
  sort: function sort(list, key, order, ignore) {
    return list.sort(function (a, b) {
      if (a.hasOwnProperty(key)) {
        var _a = a[key];
        var _b = b[key];
        if (ignore) {
          // sort strings using same case
          _a = typeof _a === 'string' ? _a.toUpperCase() : _a;
          _b = typeof _b === 'string' ? _b.toUpperCase() : _b;
        }
        if (order === 'asc') {
          if (_a < _b) return -1;
          if (_a > _b) return 1;
        }
        if (order === 'desc') {
          if (_a > _b) return -1;
          if (_a < _b) return 1;
        }
      }
      return 0;
    });
  }
});
;// CONCATENATED MODULE: ./src/js/store.js
/**
 * Basic localStorage wrapper
 */
/* harmony default export */ const store = ({
  // save data
  set: function set(key, data, ttl) {
    if (!this._isStr(key)) return;
    var time = Date.now();
    var expire = Number(ttl) || 0;
    var json = JSON.stringify({
      time: time,
      expire: expire,
      data: data
    });
    window.localStorage.setItem(key, json);
  },
  // get saved data
  get: function get(key) {
    if (!this._isStr(key)) return;
    var json = window.localStorage.getItem(key) || '{}';
    var parsed = JSON.parse(json) || {};
    var time = parsed.time,
      expire = parsed.expire,
      data = parsed.data;
    if (this._isExpired(time, expire)) this["delete"](key);
    return data;
  },
  // remove saved data
  "delete": function _delete(key) {
    if (!this._isStr(key)) return;
    window.localStorage.removeItem(key);
  },
  // check valid string
  _isStr: function _isStr(str) {
    return str && typeof str === 'string';
  },
  // check if data saved has expired
  _isExpired: function _isExpired(time, expire) {
    if (!time || !expire) return false;
    var now = Date.now();
    var secs = (now - time) / 1000;
    return secs >= expire ? true : false;
  }
});
;// CONCATENATED MODULE: ./src/app.js
function app_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = app_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function app_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return app_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return app_arrayLikeToArray(o, minLen); }
function app_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
/**
 * Main app JS entry file.
 */









// main vue app
new Vue({
  el: '#app',
  data: {
    // toggles
    init: false,
    visible: true,
    playing: false,
    loading: false,
    sidebar: false,
    volume: 100,
    // sidebar toggles
    sbActive: false,
    sbVisible: false,
    // stations stuff
    route: '/',
    stations: [],
    station: {},
    songs: [],
    track: {},
    image: {},
    deezer: {},
    favorites: [],
    errors: {},
    // timer stuff
    timeStart: 0,
    timeDisplay: '00:00:00',
    timeItv: null,
    // sorting stuff
    searchText: '',
    sortParam: 'listeners',
    sortOrder: 'desc',
    // timer stuff
    anf: null,
    sto: null,
    itv: null
  },
  // watch methods
  watch: {
    // watch playing status
    playing: function playing() {
      if (this.playing) {
        this.startClock();
      } else {
        this.stopClock();
      }
    },
    // update player volume
    volume: function volume() {
      audio.setVolume(this.volume);
    }
  },
  // computed methods
  computed: {
    // filter stations list
    channelsList: function channelsList() {
      var _this = this;
      var list = this.stations.slice();
      var search = this.searchText.replace(/[^\w\s\-]+/g, '').replace(/[\r\s\t\n]+/g, ' ').trim();
      if (search && search.length > 1) {
        list = utils.search(list, 'title', search);
      }
      if (this.sortParam) {
        list = utils.sort(list, this.sortParam, this.sortOrder, false);
      }
      if (this.station.shortcode) {
        list = list.map(function (i) {
          i.active = _this.station.shortcode === i.shortcode ? true : false;
          return i;
        });
      }
      return list;
    },
    // filter songs list
    songsList: function songsList() {
      var list = this.songs.slice();
      return list;
    },
    // sort-by label for buttons, etc
    sortLabel: function sortLabel() {
      switch (this.sortParam) {
        case 'title':
          return 'Station Name';
        case 'listeners':
          return 'Listeners Count';
        case 'favorite':
          return 'Saved Favorites';
        case 'genre':
          return 'Music Genre';
      }
    },
    // check if audio can be played
    canPlay: function canPlay() {
      return this.station.shortcode && !this.loading ? true : false;
    },
    // check if a station is selected
    hasChannel: function hasChannel() {
      return this.station.shortcode ? true : false;
    },
    // check if there are tracks loaded
    hasSongs: function hasSongs() {
      return this.songs.length ? true : false;
    },
    // check for errors that would affect playback
    hasErrors: function hasErrors() {
      if (this.errors.support || this.errors.stream) return true;
      if (this.errors.stations && !this.stations.length) return true;
      return false;
    }
  },
  // custom methods
  methods: {
    // run maintenance tasks on a timer
    setupMaintenance: function setupMaintenance() {
      var _this2 = this;
      this.itv = setInterval(function () {
        _this2.getChannels(_this2.sidebar); // update stations
        _this2.getSongs(_this2.station); // update station tracks
      }, 1000 * 30);
    },
    // set an erro message
    setError: function setError(key, err) {
      var errors = Object.assign({}, this.errors);
      errors[key] = String(err || '').trim();
      if (err) console.warn('ERROR(' + key + '):', err);
      this.errors = errors;
    },
    // clear all error messages
    clearError: function clearError(key) {
      var errors = Object.assign({}, this.errors);
      delete errors[key];
      this.errors = errors;
    },
    // check if an error has been set for a key
    hasError: function hasError(key) {
      return key && this.errors.hasOwnProperty(key);
    },
    // flush all errors
    flushErrors: function flushErrors() {
      this.errors = {};
    },
    // show player when app is mounted
    setupEvents: function setupEvents() {
      var _this3 = this;
      document.addEventListener('visibilitychange', function () {
        _this3.visible = document.visibilityState === 'visible';
      });
      window.addEventListener('hashchange', function () {
        return _this3.applyRoute(window.location.hash);
      });
      window.addEventListener('keydown', this.onKeyboard);
      // audio related events
      audio.on('waiting', this.onWaiting);
      audio.on('playing', this.onPlaying);
      audio.on('ended', this.onEnded);
      audio.on('error', this.onError);
    },
    // hide spinner and show player
    initPlayer: function initPlayer() {
      var _this4 = this;
      setTimeout(function () {
        document.querySelector('#_spnr').style.display = 'none';
        document.querySelector('#player-wrap').style.opacity = '1';
        _this4.init = true;
      }, 100);
    },
    // reset selected station
    resetPlayer: function resetPlayer() {
      this.closeAudio();
      this.flushErrors();
      this.station = {};
      this.songs = [];
    },
    // try resuming stream problem if possible
    tryAgain: function tryAgain() {
      if (this.hasError('support')) {
        this.flushErrors();
        setTimeout(this.setupAudio, 1);
      } else {
        this.flushErrors();
        this.playChannel(this.station);
      }
    },
    // show/hide the sidebar
    toggleSidebar: function toggleSidebar(toggle) {
      var _this5 = this;
      var state = typeof toggle === 'boolean' ? toggle : false;
      if (state) {
        this.sbActive = true; // bring to front
        this.sbVisible = true; // show drawer
        this.$refs.sidebarDrawer.focus();
      } else {
        this.sbVisible = false;
        setTimeout(function () {
          _this5.sbActive = false;
        }, 500);
      }
    },
    // toggle stream playback for current selected station
    togglePlay: function togglePlay(e) {
      e && e.preventDefault();
      if (this.loading) return;
      if (this.playing) return this.closeAudio();
      this.playChannel(this.station);
    },
    // save volume to store
    saveVolume: function saveVolume() {
      store.set('player_volume', this.volume);
    },
    // load saved volume from store
    loadVolume: function loadVolume() {
      var vol = parseInt(store.get('player_volume')) || 100;
      this.volume = vol;
    },
    // load last sort options from store
    loadSortOptions: function loadSortOptions() {
      var opts = store.get('sorting_data');
      if (opts && opts.param) this.sortParam = opts.param;
      if (opts && opts.order) this.sortOrder = opts.order;
    },
    // toggle sort order
    toggleSortOrder: function toggleSortOrder() {
      this.sortOrder = this.sortOrder === 'asc' ? 'desc' : 'asc';
    },
    // apply sorting and toggle order
    sortBy: function sortBy(param, order) {
      if (this.sortParam === param) {
        this.toggleSortOrder();
      } else {
        this.sortOrder = order || 'asc';
      }
      this.sortParam = param;
      store.set('sorting_data', {
        param: this.sortParam,
        order: this.sortOrder
      });
    },
    // load saved favs list from store
    loadFavorites: function loadFavorites() {
      var favs = store.get('favorites_data');
      if (!Array.isArray(favs)) return;
      this.favorites = favs;
    },
    // save favs to a .m3u file
    saveFavorites: function saveFavorites() {
      var _this6 = this;
      var data = '#EXTM3U';
      var _iterator = app_createForOfIteratorHelper(this.favorites),
        _step;
      try {
        var _loop = function _loop() {
          var id = _step.value;
          var station = _this6.stations.filter(function (c) {
            return c.shortcode === id;
          }).shift();
          if (!station) return 1; // continue
          data += '\n\n';
          data += "#EXTINF:0,".concat(station.title, " [AzuraCast]\n");
          data += "".concat(station.mp3file);
        };
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          if (_loop()) continue;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      var elm = document.createElement('a');
      elm.setAttribute('href', 'data:audio/mpegurl;charset=utf-8,' + encodeURIComponent(data));
      elm.setAttribute('download', 'azuracast_favorites.m3u');
      elm.setAttribute('target', '_blank');
      document.body.appendChild(elm);
      setTimeout(function () {
        return elm.click();
      }, 100);
      setTimeout(function () {
        return elm.remove();
      }, 1000);
    },
    // toggle favorite station by id
    toggleFavorite: function toggleFavorite(id, toggle) {
      var favs = this.favorites.slice();
      favs = favs.filter(function (fid) {
        return fid !== id;
      });
      if (toggle) favs.push(id);
      this.favorites = favs;
      this.updateCurrentChannel();
      store.set('favorites_data', favs);
    },
    // close active audio
    closeAudio: function closeAudio() {
      audio.stopAudio();
      this.playing = false;
    },
    // setup animation canvas
    setupCanvas: function setupCanvas() {
      scene.setupCanvas();
    },
    // audio visualizer animation loop
    updateCanvas: function updateCanvas() {
      this.anf = requestAnimationFrame(this.updateCanvas);
      if (this.visible) {
        var freq = audio.getFreqData(this.playing);
        scene.updateObjects(freq);
      }
    },
    // get stations data from api
    getChannels: function getChannels(sidebar) {
      var _this7 = this;
      api.getChannels(function (err, stations) {
        if (err) return _this7.setError('stations', err);
        _this7.stations = stations;
        _this7.clearError('stations');
        _this7.updateCurrentChannel();
        _this7.applyRoute(window.location.hash, sidebar);
      });
    },
    // get songs list for a station from api
    getSongs: function getSongs(station, cb) {
      var _this8 = this;
      if (!station || !station.shortcode || !station.songsurl) return;
      if (!this.isCurrentChannel(station)) {
        this.songs = [];
        this.track = {};
        this.image = {};
        this.deezer = {};
      }
      ;
      api.getSongs(station, function (err, songs) {
        if (err) return _this8.setError('songs', err);
        if (typeof cb === 'function') cb(songs);
        _this8.track = songs.now_playing.song;
        _this8.songs = songs.song_history;
        _this8.image = songs.now_playing.song;
        _this8.clearError('songs');
        // console.log("DATA => ", this.songs);

        // get cover
        var a = _this8.track.artist.replace(/ *\([^)]*\) */g, "");
        var t = _this8.track.title.replace(/ *\([^)]*\) */g, "");
        var cors = 'https://origin.cloudmu.id/?url=';
        var url = cors + 'https://api.deezer.com/search?q=artist%3A"' + a + '" track%3A"' + t + '"';
        url = encodeURI(url);
        axios.get(url, {
          method: 'GET',
          headers: {
            'content-type': 'application/json'
          }
        }).then(function (response) {
          if (response.data.data.length >= 1) {
            _this8.deezer = response.data.data[0].album;
            // console.log("COVER => ",this.deezer.cover_big);
          } else {
            _this8.deezer = _this8.image;
            console.log("%c Cover data not found => return", 'background: red; color:white');
          }
        })["catch"](function (e) {
          if (err) {
            return callback(String(e.message || ''), []);
          }
        });
      });
    },
    // checks is a station is currently selected
    isCurrentChannel: function isCurrentChannel(station) {
      if (!station || !station.shortcode || !this.station.shortcode) return false;
      if (this.station.shortcode !== station.shortcode) return false;
      return true;
    },
    // update data for current selected channel
    updateCurrentChannel: function updateCurrentChannel() {
      var _iterator2 = app_createForOfIteratorHelper(this.stations),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var c = _step2.value;
          // see if channel has been saved as a favorite
          c.favorite = this.favorites.indexOf(c.shortcode) >= 0;
          // see if channel is currently selected
          if (this.isCurrentChannel(c)) {
            this.station = Object.assign(this.station, c);
            c.active = true;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    },
    // play audio stream for a station
    playChannel: function playChannel(station) {
      if (this.playing || !station || !station.mp3file) return;
      this.loading = true;
      audio.playSource(station.mp3file);
      audio.setVolume(this.volume);
    },
    // select a station to play
    selectChannel: function selectChannel(station) {
      var play = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (!station || !station.shortcode) return;
      if (this.isCurrentChannel(station)) return;
      this.closeAudio();
      this.toggleSidebar(false);
      this.setRoute(station.route);
      this.getSongs(station);
      this.station = station;
      // attempt to play only after user insteraction, triggered from clicking a station on the list
      if (play) {
        this.playChannel(station);
      }
    },
    // set station route
    setRoute: function setRoute(route) {
      route = '/' + String(route || '').replace(/^[\#\/]+|[\/]+$/g, '').trim();
      window.location.hash = route;
      this.route = route;
    },
    // parse url hash route actions
    applyRoute: function applyRoute(route) {
      var sidebar = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var data = String(route || '').replace(/^[\#\/]+|[\/]+$/g, '').trim().split('/');
      var action = data.length ? data.shift() : '';
      var param = data.length ? data.shift() : '';

      // select a station from the url
      if (action === 'station' && param) {
        var station = this.stations.filter(function (c) {
          return c.shortcode === param;
        }).shift();
        if (station && station.shortcode) {
          return this.selectChannel(station);
        }
      }
      // nothing to do, reset player
      this.closeAudio();
      this.resetPlayer();
      this.toggleSidebar(sidebar);
    },
    // on keyboard events
    onKeyboard: function onKeyboard(e) {
      var k = e.key || '';
      if (k === ' ' && this.station.shortcode) return this.togglePlay();
      if (k === 'Enter') return this.toggleSidebar(true);
      if (k === 'Escape') return this.toggleSidebar(false);
    },
    // waiting for media to load
    onWaiting: function onWaiting(e) {
      var _this9 = this;
      if (this.sto) clearInterval(this.sto);
      this.sto = setTimeout(function () {
        return _this9.onError(e);
      }, 10000);
      this.playing = false;
      this.loading = true;
    },
    // audio stream playing
    onPlaying: function onPlaying(e) {
      this.clearError('stream');
      this.playing = true;
      this.loading = false;
    },
    // audio stream ended
    onEnded: function onEnded(e) {
      this.playing = false;
      this.loading = false;
    },
    // error loading stream
    onError: function onError(e) {
      this.closeAudio();
      this.setError('stream', "The selected stream (".concat(this.station.title, ") could not load, or stopped loading due to network problems."));
      this.playing = false;
      this.loading = false;
    },
    // start tracking playback time
    startClock: function startClock() {
      this.stopClock();
      this.timeStart = Date.now();
      this.timeItv = setInterval(this.updateClock, 1000);
      this.updateClock();
    },
    // update tracking playback time
    updateClock: function updateClock() {
      var p = function p(n) {
        return n < 10 ? '0' + n : '' + n;
      };
      var elapsed = (Date.now() - this.timeStart) / 1000;
      var seconds = Math.floor(elapsed % 60);
      var minutes = Math.floor(elapsed / 60 % 60);
      var hours = Math.floor(elapsed / 3600);
      this.timeDisplay = p(hours) + ':' + p(minutes) + ':' + p(seconds);
    },
    // stop tracking playback time
    stopClock: function stopClock() {
      if (this.timeItv) clearInterval(this.timeItv);
      this.timeItv = null;
    },
    // clear timer refs
    clearTimers: function clearTimers() {
      if (this.sto) clearTimeout(this.sto);
      if (this.itv) clearInterval(this.itv);
      if (this.anf) cancelAnimationFrame(this.anf);
    },
    // pass height property to css
    setCssHeight: function setCssHeight(elm, height) {
      elm.style.setProperty('--height', "".concat(height, "px"));
    },
    // keep track of window height
    updateHeight: function updateHeight() {
      var _this10 = this;
      var root = document.querySelector(':root');
      this.setCssHeight(root, window.innerHeight);
      window.addEventListener('resize', function (e) {
        return _this10.setCssHeight(root, window.innerHeight);
      });
    } // ...
  },
  // on app mounted
  mounted: function mounted() {
    this.loadSortOptions();
    this.loadFavorites();
    this.loadVolume();
    this.setupEvents();
    this.getChannels(true);
    this.setupCanvas();
    this.updateCanvas();
    this.setupMaintenance();
    this.updateHeight();
    this.initPlayer();
  },
  // on app destroyed
  destroyed: function destroyed() {
    this.closeAudio();
    this.clearTimers();
  }
});
})();

/******/ })()
;